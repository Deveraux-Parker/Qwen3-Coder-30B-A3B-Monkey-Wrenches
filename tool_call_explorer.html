<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QWEN XML Tool Call Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            overflow-x: hidden;
        }

        h1 {
            text-align: center;
            color: #e0e0e0;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.7);
            position: relative;
            font-weight: 300;
            letter-spacing: 2px;
        }
        
        .settings-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .settings-icon:hover {
            opacity: 1;
            transform: translateY(-50%) rotate(90deg);
        }
        
        .settings-icon svg {
            width: 100%;
            height: 100%;
            fill: white;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background-color: #1e1e2e;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.7);
            animation: slideDown 0.3s ease;
            border: 1px solid #3a3a5e;
        }
        
        @keyframes slideDown {
            from { 
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #3a3a5e;
        }
        
        .modal-header h2 {
            color: #e0e0e0;
            margin: 0;
        }
        
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
            line-height: 20px;
        }
        
        .close:hover,
        .close:focus {
            color: #6a6aae;
        }
        
        .settings-group {
            margin-bottom: 20px;
        }
        
        .settings-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-weight: 600;
        }
        
        .settings-group input,
        .settings-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #3a3a5e;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
            background: #0a0a1e;
            color: #e0e0e0;
        }
        
        .settings-group input:focus,
        .settings-group select:focus {
            outline: none;
            border-color: #4a4a7e;
            background: #0f0f2e;
        }
        
        .settings-group small {
            display: block;
            margin-top: 5px;
            color: #999;
            font-size: 12px;
        }
        
        .settings-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .btn-save {
            background: linear-gradient(135deg, #2a2a5e 0%, #3a3a6e 100%);
            color: white;
            padding: 10px 20px;
            border: 1px solid #4a4a7e;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-cancel {
            background: #2a2a3e;
            color: #e0e0e0;
            padding: 10px 20px;
            border: 1px solid #3a3a5e;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn-cancel:hover {
            background: #3a3a4e;
        }
        
        /* Tool Builder Styles */
        .tool-builder-btn {
            background: linear-gradient(135deg, #4a2a7e 0%, #5a3a8e 100%);
            color: white;
            padding: 10px 20px;
            border: 1px solid #6a4a9e;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
        }
        
        .tool-builder-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #5a3a8e 0%, #6a4a9e 100%);
        }
        
        .quick-prompt-item {
            display: inline-flex;
            align-items: center;
            margin: 5px;
            padding: 4px 10px;
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 12px;
        }
        
        .quick-prompt-item button {
            background: transparent;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 12px;
        }
        
        .quick-prompt-item button:hover {
            color: #f87171;
        }
        
        .remove-prompt-btn {
            margin-left: 8px;
            color: #f87171 !important;
            font-weight: bold;
        }
        
        .tool-step {
            background: #0a0a1e;
            border: 1px solid #2a2a3e;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .tool-step h4 {
            color: #6a6aae;
            margin-bottom: 10px;
        }
        
        .tool-step.active {
            border-color: #4a4a7e;
            background: #1a1a3e;
        }
        
        .tool-step.completed {
            border-color: #2a5a4e;
        }
        
        .tool-step.error {
            border-color: #5a2a2e;
        }
        
        .validation-result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 13px;
        }
        
        .validation-success {
            background: #1a3a2e;
            color: #4ade80;
            border: 1px solid #2a5a4e;
        }
        
        .validation-error {
            background: #3a1a1e;
            color: #f87171;
            border: 1px solid #5a2a2e;
        }
        
        .tool-test-area {
            background: #0a0a1e;
            border: 1px solid #2a2a3e;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
        }

        .main-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            gap: 20px;
            margin-bottom: 20px;
            width: 100%;
            overflow-x: hidden;
        }

        .panel {
            background: #1e1e2e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            overflow: hidden;
            width: 100%;
            min-width: 0;
            border: 1px solid #2a2a3e;
        }

        .panel h2 {
            color: #e0e0e0;
            margin-bottom: 15px;
            border-bottom: 2px solid #3a3a5e;
            padding-bottom: 10px;
            font-weight: 400;
        }

        .input-section {
            margin-bottom: 20px;
        }

        .input-section label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-weight: 600;
        }

        .input-section textarea {
            width: 100%;
            min-height: 300px;
            padding: 10px;
            border: 2px solid #3a3a5e;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            background: #0a0a1e;
            color: #e0e0e0;
        }

        .input-section textarea:focus {
            outline: none;
            border-color: #4a4a7e;
            background: #0f0f2e;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #2a2a5e 0%, #3a3a6e 100%);
            color: white;
            border: 1px solid #4a4a7e;
        }

        .btn-secondary {
            background: #2a2a3e;
            color: #e0e0e0;
            border: 1px solid #3a3a5e;
        }

        .btn-success {
            background: #1a3a2e;
            color: #4ade80;
            border: 1px solid #2a5a4e;
        }

        .output-section {
            background: #0a0a1e;
            border-radius: 5px;
            padding: 15px;
            min-height: 200px;
            max-height: 500px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
            border: 1px solid #2a2a3e;
        }

        .tool-call-display {
            background: #1a1a2e;
            border: 2px solid #3a3a5e;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            word-wrap: break-word;
            overflow: hidden;
        }

        .tool-call-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .tool-icon {
            width: 30px;
            height: 30px;
            background: #3a3a5e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
        }

        .tool-icon svg {
            width: 16px;
            height: 16px;
            fill: white;
        }

        .function-name {
            font-size: 18px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .parameters {
            margin-top: 10px;
        }

        .parameter {
            display: flex;
            padding: 8px;
            background: #0a0a1e;
            border-radius: 3px;
            margin-bottom: 5px;
            gap: 10px;
            align-items: flex-start;
            border: 1px solid #2a2a3e;
        }

        .param-name {
            font-weight: 600;
            color: #6a6aae;
            min-width: 120px;
            flex-shrink: 0;
        }

        .param-value {
            color: #b0b0b0;
            font-family: 'Courier New', monospace;
            word-break: break-word;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            max-width: 100%;
        }

        .examples-panel {
            grid-column: 1 / -1;
        }

        .example-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .example-btn {
            padding: 8px 15px;
            background: #1a1a2e;
            border: 2px solid #3a3a5e;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            color: #e0e0e0;
        }

        .example-btn:hover {
            background: #2a2a5e;
            color: white;
            border-color: #4a4a7e;
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }

        .status-success {
            background: #1a3a2e;
            color: #4ade80;
            border: 1px solid #2a5a4e;
        }

        .status-error {
            background: #3a1a1e;
            color: #f87171;
            border: 1px solid #5a2a2e;
        }
        
        .status-warning {
            background: #3a3a1e;
            color: #fbbf24;
            border: 1px solid #5a5a2e;
        }
        
        .recovery-indicator {
            display: inline-block;
            padding: 4px 8px;
            background: #2a4a5e;
            color: #60a5fa;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 10px;
            animation: pulse 1s ease-in-out;
            border: 1px solid #3a5a6e;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .json-view {
            background: #0a0a1e;
            color: #e0e0e0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 400px;
            word-wrap: break-word;
            width: 100%;
            box-sizing: border-box;
            border: 1px solid #2a2a3e;
        }
        
        .json-view pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .raw-xml {
            background: #0a0a1e;
            border: 1px solid #2a2a3e;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #808080;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .stream-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #4ade80;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        .token-stream {
            background: #0a0a1e;
            color: #4ade80;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            min-height: 50px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #2a2a3e;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            🔧 QWEN XML Tool Call Explorer
            <div class="settings-icon" onclick="openSettings()">
                <svg viewBox="0 0 24 24">
                    <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                </svg>
            </div>
        </h1>
        
        <div class="main-layout">
            <!-- Input Panel -->
            <div class="panel">
                <h2>Input XML Tool Call</h2>
                <div class="input-section">
                    <label for="xmlInput" style="color: #e0e0e0;">Enter XML Tool Call:</label>
                    <textarea id="xmlInput" placeholder="<tool_call>
<function=calculator</function>
<parameter=operation>add</parameter>
<parameter=a>5</parameter>
<parameter=b>3</parameter>
</tool_call>"></textarea>
                    
                    <div class="button-group">
                        <button class="btn-primary" onclick="parseToolCall()">Parse Tool Call</button>
                        <button class="btn-secondary" onclick="clearInput()">Clear</button>
                        <button class="btn-success" onclick="simulateStreaming()">Simulate Streaming</button>
                    </div>
                    
                    <div style="margin-top: 20px; border-top: 2px solid #3a3a5e; padding-top: 15px;">
                        <label for="promptInput" style="font-weight: 600; color: #e0e0e0;">Prompt for VLLM (Generate Tool Call):</label>
                        
                        <div style="margin: 10px 0;">
                            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                <span style="font-size: 13px; color: #808080;">Quick prompts:</span>
                                <button class="tool-builder-btn" onclick="openToolBuilder()" style="margin-left: auto;">
                                    🔧 Build New Tool
                                </button>
                            </div>
                            <div id="quickPromptsList">
                                <!-- Quick prompts will be dynamically loaded here -->
                            </div>
                        </div>
                        
                        <textarea id="promptInput" style="width: 100%; min-height: 120px; padding: 10px; border: 2px solid #3a3a5e; border-radius: 5px; font-family: 'Segoe UI', sans-serif; font-size: 14px; margin-top: 5px; background: #0a0a1e; color: #e0e0e0;" placeholder="Enter a prompt to generate tool calls from VLLM. Example:

Use the calculator tool to multiply 15 by 23.

To use tools, respond with:
<tool_call>
<function=tool_name</function>
<parameter=param_name>value</parameter>
</tool_call>" oninput="updateRequestPreview()"></textarea>
                        
                        <div class="button-group" style="margin-top: 10px;">
                            <button class="btn-primary" onclick="callVLLM(false)" style="background: linear-gradient(135deg, #1a3a2e 0%, #2a4a3e 100%); border: 1px solid #3a5a4e;">
                                🚀 Call VLLM (Non-Streaming)
                            </button>
                            <button class="btn-primary" onclick="callVLLM(true)" style="background: linear-gradient(135deg, #1a3a4e 0%, #2a4a5e 100%); border: 1px solid #3a5a6e;">
                                ⚡ Call VLLM (Streaming)
                            </button>
                            <button class="btn-secondary" onclick="stopStreaming()" id="stopStreamBtn" style="display: none; background: #5a2a2e; border: 1px solid #7a3a3e;">
                                ⏹ Stop Streaming
                            </button>
                        </div>
                    </div>
                    
                    <div id="statusMessage" class="status-message"></div>
                    
                    <!-- Request Preview Section -->
                    <div style="margin-top: 20px; border-top: 2px solid #3a3a5e; padding-top: 15px;">
                        <h3 style="font-size: 16px; color: #e0e0e0; margin-bottom: 10px;">
                            Request Preview
                            <span style="font-size: 12px; color: #808080; font-weight: normal; margin-left: 10px;">(What will be sent to VLLM)</span>
                        </h3>
                        
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button onclick="togglePreviewMode('formatted')" id="previewFormatted" style="padding: 6px 12px; background: #3a3a5e; color: white; border: 1px solid #4a4a7e; border-radius: 3px; cursor: pointer; font-size: 13px;">Chat Template</button>
                            <button onclick="togglePreviewMode('json')" id="previewJson" style="padding: 6px 12px; background: #2a2a3e; color: white; border: 1px solid #3a3a5e; border-radius: 3px; cursor: pointer; font-size: 13px;">JSON Payload</button>
                        </div>
                        
                        <div id="requestPreview" style="background: #0a0a1e; color: #d4d4d4; padding: 15px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 12px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #2a2a3e;">
                            <span style="color: #999;">Enter a prompt to see the request preview...</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Output Panel -->
            <div class="panel">
                <h2>Parsed Output</h2>
                <div class="output-section" id="outputSection">
                    <p style="color: #999; text-align: center;">Parsed tool calls will appear here...</p>
                </div>
                
                <h3 style="margin-top: 20px; margin-bottom: 10px; color: #e0e0e0;">JSON Representation</h3>
                <div class="json-view" id="jsonView">
                    <pre>{}</pre>
                </div>
                
                <h3 style="margin-top: 20px; margin-bottom: 10px; color: #e0e0e0;">Raw LLM Response</h3>
                <div style="background: #0a0a1e; color: #4ade80; padding: 10px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 12px; max-height: 200px; overflow-y: auto; overflow-x: hidden; white-space: pre-wrap; word-break: break-word; word-wrap: break-word; border: 1px solid #2a2a3e;" id="rawResponse">
                    <span style="color: #999;">No response yet...</span>
                </div>
                
                <h3 style="margin-top: 20px; margin-bottom: 10px; color: #e0e0e0;">Raw JSON Response</h3>
                <div style="background: #0a0a1e; color: #d4d4d4; padding: 10px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 11px; max-height: 250px; overflow-y: auto; overflow-x: auto; border: 1px solid #2a2a3e;" id="rawJsonResponse">
                    <pre style="margin: 0; color: #d4d4d4; white-space: pre-wrap; word-wrap: break-word;">No JSON response yet...</pre>
                </div>
                
                <div class="token-stream" id="tokenStream" style="display: none;">
                    <span id="streamContent"></span><span class="stream-indicator"></span>
                </div>
            </div>
        </div>
        
        <!-- Parsing Failures Panel -->
        <div class="panel" style="margin-top: 20px;">
            <h2>Parsing Failure Log</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn-secondary" onclick="viewFailures()">View Failures</button>
                <button class="btn-secondary" onclick="clearFailures()">Clear Log</button>
                <button class="btn-success" onclick="exportFailures()">Export Log</button>
                <span id="failureCount" style="margin-left: auto; padding: 8px 15px; background: #1a1a2e; border-radius: 5px; font-weight: 600; color: #e0e0e0; border: 1px solid #3a3a5e;"></span>
            </div>
            <div id="failuresDisplay" style="display: none; max-height: 400px; overflow-y: auto;">
                <!-- Failures will be displayed here -->
            </div>
        </div>
    </div>
    
    <!-- Tool Builder Modal -->
    <div id="toolBuilderModal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>🔧 AI Tool Builder</h2>
                <span class="close" onclick="closeToolBuilder()">&times;</span>
            </div>
            
            <div id="toolBuilderContent">
                <!-- Step 1: Describe the Tool -->
                <div id="step1" class="tool-step active">
                    <h4>Step 1: Describe Your Tool</h4>
                    <label style="color: #e0e0e0;">What should this tool do?</label>
                    <textarea id="toolDescription" style="width: 100%; min-height: 100px; padding: 10px; border: 2px solid #3a3a5e; border-radius: 5px; background: #0a0a1e; color: #e0e0e0; margin-top: 10px;" placeholder="Example: I need a tool that converts temperatures between Celsius, Fahrenheit, and Kelvin"></textarea>
                    
                    <label style="color: #e0e0e0; margin-top: 15px;">Tool Name (short, descriptive):</label>
                    <input type="text" id="toolName" style="width: 100%; padding: 10px; border: 2px solid #3a3a5e; border-radius: 5px; background: #0a0a1e; color: #e0e0e0; margin-top: 5px;" placeholder="e.g., temperature_converter">
                    
                    <button class="btn-primary" onclick="generateToolDefinition()" style="margin-top: 15px;">Generate Tool Definition with AI</button>
                </div>
                
                <!-- Step 2: Review & Refine -->
                <div id="step2" class="tool-step" style="display: none;">
                    <h4>Step 2: Review Generated Definition</h4>
                    <div id="generatedDefinition" style="background: #0a0a1e; border: 1px solid #2a2a3e; border-radius: 5px; padding: 15px; margin-top: 10px;">
                        <!-- Generated definition will appear here -->
                    </div>
                    <button class="btn-primary" onclick="validateToolDefinition()" style="margin-top: 15px;">Validate Tool</button>
                    <button class="btn-secondary" onclick="regenerateToolDefinition()" style="margin-top: 15px;">Regenerate</button>
                </div>
                
                <!-- Step 3: Test the Tool -->
                <div id="step3" class="tool-step" style="display: none;">
                    <h4>Step 3: Test Your Tool</h4>
                    <label style="color: #e0e0e0;">Test Prompt:</label>
                    <textarea id="testPrompt" style="width: 100%; min-height: 80px; padding: 10px; border: 2px solid #3a3a5e; border-radius: 5px; background: #0a0a1e; color: #e0e0e0; margin-top: 10px;" placeholder="Enter a prompt to test your new tool"></textarea>
                    
                    <button class="btn-primary" onclick="testNewTool()" style="margin-top: 15px;">Test Tool Call</button>
                    
                    <div id="testResults" class="tool-test-area" style="display: none; margin-top: 15px;">
                        <!-- Test results will appear here -->
                    </div>
                </div>
                
                <!-- Step 4: Save the Tool -->
                <div id="step4" class="tool-step" style="display: none;">
                    <h4>Step 4: Save Your Tool</h4>
                    <div class="validation-success">
                        <p>✅ Your tool has been validated and tested successfully!</p>
                    </div>
                    
                    <label style="color: #e0e0e0; margin-top: 15px;">Quick Prompt Label:</label>
                    <input type="text" id="quickPromptLabel" style="width: 100%; padding: 10px; border: 2px solid #3a3a5e; border-radius: 5px; background: #0a0a1e; color: #e0e0e0; margin-top: 5px;" placeholder="e.g., Convert Temp">
                    
                    <button class="btn-success" onclick="saveNewTool()" style="margin-top: 15px;">💾 Save Tool</button>
                </div>
            </div>
            
            <div id="toolBuilderStatus" class="status-message" style="margin-top: 20px; display: none;"></div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>AI Settings</h2>
                <span class="close" onclick="closeSettings()">&times;</span>
            </div>
            
            <div class="settings-group">
                <label for="serverUrl" style="color: #e0e0e0;">Server URL</label>
                <input type="text" id="serverUrl" placeholder="http://localhost">
                <small style="color: #808080;">The base URL of your OpenAI-compatible server</small>
            </div>
            
            <div class="settings-group">
                <label for="serverPort" style="color: #e0e0e0;">Port</label>
                <input type="number" id="serverPort" placeholder="8000" min="1" max="65535">
                <small style="color: #808080;">The port number (1-65535)</small>
            </div>
            
            <div class="settings-group">
                <label for="temperature" style="color: #e0e0e0;">Temperature</label>
                <input type="number" id="temperature" placeholder="0.3" min="0" max="2" step="0.1">
                <small style="color: #808080;">Controls randomness (0.0 = deterministic, 2.0 = very random)</small>
            </div>
            
            <div class="settings-group">
                <label for="topP" style="color: #e0e0e0;">Top P</label>
                <input type="number" id="topP" placeholder="0.95" min="0" max="1" step="0.01">
                <small style="color: #808080;">Nucleus sampling threshold (0.0-1.0)</small>
            </div>
            
            <div class="settings-group">
                <label for="minP" style="color: #e0e0e0;">Min P</label>
                <input type="number" id="minP" placeholder="0.05" min="0" max="1" step="0.01">
                <small style="color: #808080;">Minimum probability threshold for token selection (0.0-1.0)</small>
            </div>
            
            <div class="settings-group">
                <label for="apiKey" style="color: #e0e0e0;">API Key (Optional)</label>
                <input type="password" id="apiKey" placeholder="Leave blank for local VLLM">
                <small style="color: #808080;">Add an API key if your endpoint requires authentication</small>
            </div>
            
            <div class="settings-actions">
                <button class="btn-save" onclick="saveSettings()">Save Settings</button>
                <button class="btn-cancel" onclick="closeSettings()">Cancel</button>
                <button class="btn-secondary" onclick="resetSettings()">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <script>
        // XML Tool Parser
        class XMLToolParser {
            constructor() {
                this.toolCallRegex = /<tool_call>([\s\S]*?)<\/tool_call>/g;
                this.functionRegex = /<function=([^<>]+?)(?:<\/function>|>)/;
                this.parameterRegex = /<parameter=([^<>=]+)>([\s\S]*?)<\/parameter>/g;
                // Fallback regex for when <tool_call> tag is missing
                this.functionOnlyRegex = /(<function=[\s\S]*?<\/tool_call>)/g;
                // Pattern for function-only format (no tool_call tags at all)
                this.functionOnlyPattern = /(<function=[\s\S]*?<\/function>)/g;
            }

            countExpectedParameters(content) {
                // Count how many parameter tags exist (regardless of format)
                const paramMatches = content.match(/<parameter=/g);
                return paramMatches ? paramMatches.length : 0;
            }
            
            parse(xmlText) {
                const toolCalls = [];
                let match;

                // Reset regex state
                this.toolCallRegex.lastIndex = 0;
                this.functionOnlyRegex.lastIndex = 0;

                // First try standard format with <tool_call> tags
                while ((match = this.toolCallRegex.exec(xmlText)) !== null) {
                    const toolContent = match[1];
                    const fullMatch = match[0]; // Store the full matched string
                    const toolCall = this.parseToolCall(toolContent, fullMatch);
                    if (toolCall) {
                        toolCalls.push(toolCall);
                    }
                }

                // If no tool calls found, try fallback pattern (missing <tool_call> opening tag)
                if (toolCalls.length === 0) {
                    while ((match = this.functionOnlyRegex.exec(xmlText)) !== null) {
                        const funcName = match[1];
                        const content = match[0];
                        // Reconstruct as if it had the opening tag
                        const reconstructed = `<function=${funcName}>${content.substring(content.indexOf('>') + 1)}`;
                        const toolCall = this.parseToolCall(reconstructed, `<tool_call>${content}`);
                        if (toolCall) {
                            toolCalls.push(toolCall);
                        }
                    }
                }
                
                // If still no matches, try function-only format (no tool_call tags at all)
                if (toolCalls.length === 0) {
                    this.functionOnlyPattern.lastIndex = 0;
                    while ((match = this.functionOnlyPattern.exec(xmlText)) !== null) {
                        const content = match[1];
                        const toolCall = this.parseToolCall(content, match[0]);
                        if (toolCall) {
                            toolCalls.push(toolCall);
                        }
                    }
                }

                return toolCalls;
            }

            parseToolCall(content, rawXml = null) {
                // Extract function name
                const funcMatch = content.match(this.functionRegex);
                if (!funcMatch) {
                    // Try to handle truncated cases where function might not be properly closed
                    const truncatedMatch = content.match(/<function=([^<>]+)(?:\s|$)/);
                    if (truncatedMatch) {
                        const functionName = truncatedMatch[1].trim();
                        // Still try to extract any parameters that might be there
                        return this.extractParametersOnly(functionName, content, rawXml);
                    }
                    return null;
                }

                const functionName = funcMatch[1].trim();
                const parameters = {};

                // First try standard parameter format: <parameter=name>value</parameter>
                let paramMatch;
                this.parameterRegex.lastIndex = 0;
                
                while ((paramMatch = this.parameterRegex.exec(content)) !== null) {
                    const paramName = paramMatch[1];
                    let paramValue = paramMatch[2].trim();
                    
                    // Clean up value
                    if (paramValue.startsWith('\n')) {
                        paramValue = paramValue.substring(1);
                    }
                    if (paramValue.endsWith('\n')) {
                        paramValue = paramValue.slice(0, -1);
                    }
                    
                    // Try to parse as JSON if possible (for numbers, booleans, etc)
                    try {
                        const parsed = JSON.parse(paramValue);
                        // Only use parsed value for numbers and booleans, not strings
                        if (typeof parsed === 'number' || typeof parsed === 'boolean') {
                            paramValue = parsed;
                        }
                    } catch {
                        // Keep as string if not valid JSON
                    }
                    
                    parameters[paramName] = paramValue;
                }

                // Second pass: try malformed format: <parameter=name=value</parameter>
                // Always run this to catch mixed format parameters
                const malformedParamRegex = /<parameter=([^<>=]+)=([^<>]+)<\/parameter>/g;
                malformedParamRegex.lastIndex = 0;
                
                while ((paramMatch = malformedParamRegex.exec(content)) !== null) {
                    const paramName = paramMatch[1].trim();
                    let paramValue = paramMatch[2].trim();
                    
                    // Only add if not already found in standard format
                    if (!(paramName in parameters)) {
                        // Try to parse as JSON if possible
                        try {
                            const parsed = JSON.parse(paramValue);
                            if (typeof parsed === 'number' || typeof parsed === 'boolean') {
                                paramValue = parsed;
                            }
                        } catch {
                            // Keep as string
                        }
                        
                        parameters[paramName] = paramValue;
                    }
                }
                
                // Third pass: handle empty parameter tags with values after closing tag
                // Format: <parameter=name></parameter>\nvalue
                const emptyParamRegex = /<parameter=([^<>=]+)><\/parameter>\s*([^\s<][^<]*?)(?=\s*<|$)/g;
                emptyParamRegex.lastIndex = 0;
                
                while ((paramMatch = emptyParamRegex.exec(content)) !== null) {
                    const paramName = paramMatch[1].trim();
                    let paramValue = paramMatch[2].trim();
                    
                    // Only add if not already found
                    if (!(paramName in parameters)) {
                        // Try to parse as JSON if possible
                        try {
                            const parsed = JSON.parse(paramValue);
                            if (typeof parsed === 'number' || typeof parsed === 'boolean') {
                                paramValue = parsed;
                            }
                        } catch {
                            // Keep as string
                        }
                        
                        parameters[paramName] = paramValue;
                    }
                }
                
                // Fourth pass: handle truly malformed format where values come after </parameter> tag
                // Format: <parameter=name></parameter>value>
                const malformedEmptyRegex = /<parameter=([^<>=]+)><\/parameter>([^<>]+)>/g;
                malformedEmptyRegex.lastIndex = 0;
                
                while ((paramMatch = malformedEmptyRegex.exec(content)) !== null) {
                    const paramName = paramMatch[1].trim();
                    let paramValue = paramMatch[2].trim();
                    
                    // Only add if not already found
                    if (!(paramName in parameters)) {
                        // Try to parse as JSON if possible
                        try {
                            const parsed = JSON.parse(paramValue);
                            if (typeof parsed === 'number' || typeof parsed === 'boolean') {
                                paramValue = parsed;
                            }
                        } catch {
                            // Keep as string
                        }
                        
                        parameters[paramName] = paramValue;
                    }
                }

                // Check for parsing issues
                const paramCount = Object.keys(parameters).length;
                const expectedParams = this.countExpectedParameters(content);
                
                if (expectedParams > 0 && paramCount === 0) {
                    failureLogger.logPartialSuccess(rawXml || content, {
                        function: functionName,
                        parameters: {}
                    }, {
                        issue: 'no_parameters_parsed',
                        expectedCount: expectedParams,
                        actualCount: 0,
                        rawContent: content
                    });
                } else if (expectedParams > paramCount) {
                    failureLogger.logPartialSuccess(rawXml || content, {
                        function: functionName,
                        parameters: parameters
                    }, {
                        issue: 'missing_parameters',
                        expectedCount: expectedParams,
                        actualCount: paramCount,
                        parsedParams: Object.keys(parameters)
                    });
                }
                
                return {
                    function: functionName,
                    parameters: parameters,
                    raw: rawXml || `<tool_call>${content}</tool_call>`
                };
            }
            
            extractParametersOnly(functionName, content, rawXml) {
                // Helper method for truncated content
                const parameters = {};
                
                // Try all three parameter extraction methods
                this.parameterRegex.lastIndex = 0;
                let paramMatch;
                
                while ((paramMatch = this.parameterRegex.exec(content)) !== null) {
                    const paramName = paramMatch[1].trim();
                    let paramValue = paramMatch[2].trim();
                    
                    try {
                        const parsed = JSON.parse(paramValue);
                        if (typeof parsed === 'number' || typeof parsed === 'boolean') {
                            paramValue = parsed;
                        }
                    } catch {
                        // Keep as string
                    }
                    
                    parameters[paramName] = paramValue;
                }
                
                // Try malformed format
                const malformedParamRegex = /<parameter=([^<>=]+)=([^<>]+)<\/parameter>/g;
                malformedParamRegex.lastIndex = 0;
                
                while ((paramMatch = malformedParamRegex.exec(content)) !== null) {
                    const paramName = paramMatch[1].trim();
                    let paramValue = paramMatch[2].trim();
                    
                    if (!(paramName in parameters)) {
                        try {
                            const parsed = JSON.parse(paramValue);
                            if (typeof parsed === 'number' || typeof parsed === 'boolean') {
                                paramValue = parsed;
                            }
                        } catch {
                            // Keep as string
                        }
                        
                        parameters[paramName] = paramValue;
                    }
                }
                
                // Handle malformed empty parameter format
                const malformedEmptyRegex = /<parameter=([^<>=]+)><\/parameter>([^<>]+)>/g;
                malformedEmptyRegex.lastIndex = 0;
                
                while ((paramMatch = malformedEmptyRegex.exec(content)) !== null) {
                    const paramName = paramMatch[1].trim();
                    let paramValue = paramMatch[2].trim();
                    
                    if (!(paramName in parameters)) {
                        try {
                            const parsed = JSON.parse(paramValue);
                            if (typeof parsed === 'number' || typeof parsed === 'boolean') {
                                paramValue = parsed;
                            }
                        } catch {
                            // Keep as string
                        }
                        
                        parameters[paramName] = paramValue;
                    }
                }
                
                return {
                    function: functionName,
                    parameters: parameters,
                    raw: rawXml || content,
                    truncated: true
                };
            }
        }

        const parser = new XMLToolParser();
        
        // Parsing Failure Logger
        class ParsingFailureLogger {
            constructor() {
                this.storageKey = 'xmlToolCallParsingFailures';
                this.maxFailures = 50; // Keep last 50 failures
            }
            
            logFailure(input, reason, context = {}) {
                const failures = this.getFailures();
                const failure = {
                    id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    timestamp: new Date().toISOString(),
                    input: input,
                    reason: reason,
                    context: context,
                    userAgent: navigator.userAgent,
                    parsedParameters: context.parsedParameters || {},
                    expectedFormat: context.expectedFormat || null
                };
                
                failures.unshift(failure);
                
                // Keep only last N failures
                if (failures.length > this.maxFailures) {
                    failures.splice(this.maxFailures);
                }
                
                localStorage.setItem(this.storageKey, JSON.stringify(failures));
                console.warn('Parsing failure logged:', failure);
                
                return failure;
            }
            
            logPartialSuccess(input, parsed, issues) {
                return this.logFailure(input, 'partial_parse', {
                    parsed: parsed,
                    issues: issues,
                    type: 'warning'
                });
            }
            
            getFailures() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.error('Failed to get parsing failures:', e);
                    return [];
                }
            }
            
            clearFailures() {
                localStorage.removeItem(this.storageKey);
            }
            
            exportFailures() {
                const failures = this.getFailures();
                const blob = new Blob([JSON.stringify(failures, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `parsing_failures_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }
        
        const failureLogger = new ParsingFailureLogger();
        
        // Simulated VLLM Responses Storage
        const simulatedResponses = {
            calculator: {
                prompt: "Use the calculator tool to multiply 15 by 23.",
                response: `<tool_call>
<function=calculator</function>
<parameter=operation>multiply</parameter>
<parameter=a>15</parameter>
<parameter=b>23</parameter>
</tool_call>`,
                chunks: ["<tool_", "call>\n", "<function", "=calculator", "</function>\n", "<parameter", "=operation>", "multiply", "</parameter>\n", "<parameter", "=a>", "15", "</parameter>\n", "<parameter", "=b>", "23", "</parameter>\n", "</tool_call>"]
            },
            
            edit: {
                prompt: `Use the edit_paragraph tool to improve this paragraph:\n\n"The conference room was busy. People were talking and working on their laptops. The meeting would start soon. Everyone seemed prepared for the presentation."\n\nThis paragraph (ID: 1) needs to be more engaging and descriptive. Use the edit_paragraph tool to enhance it with better flow, sensory details, and more vivid language.`,
                response: `<tool_call>
<function=edit_paragraph</function>
<parameter=paragraph_id>1</parameter>
<parameter=reason>Lacks descriptive language and sensory details, choppy sentence structure</parameter>
<parameter=new_content>The conference room buzzed with anticipation as colleagues huddled over glowing laptops, their fingers dancing across keyboards in a final flurry of preparation. The soft murmur of last-minute discussions filled the air, punctuated by the occasional nervous laugh. Through the floor-to-ceiling windows, morning sunlight streamed in, casting long shadows across the polished table where carefully arranged portfolios awaited their moment. As the clock ticked toward the hour, a palpable energy settled over the room—everyone was ready to make their mark.</parameter>
</tool_call>`,
                chunks: ["<tool_call>\n", "<function=", "edit_paragraph", "</function>\n", "<parameter=", "paragraph_id>", "1", "</parameter>\n", "<parameter=", "reason>", "Lacks descriptive language ", "and sensory details, ", "choppy sentence structure", "</parameter>\n", "<parameter=", "new_content>", "The conference room ", "buzzed with anticipation ", "as colleagues huddled ", "over glowing laptops, ", "their fingers dancing ", "across keyboards in ", "a final flurry of ", "preparation. ", "The soft murmur ", "of last-minute discussions ", "filled the air, ", "punctuated by the ", "occasional nervous laugh. ", "Through the floor-to-ceiling ", "windows, morning sunlight ", "streamed in, casting ", "long shadows across ", "the polished table ", "where carefully arranged ", "portfolios awaited ", "their moment. ", "As the clock ticked ", "toward the hour, ", "a palpable energy ", "settled over the room", "—everyone was ready ", "to make their mark.", "</parameter>\n", "</tool_call>"]
            },
            
            email: {
                prompt: `Write an email to john@example.com about tomorrow's Q4 planning meeting at 2 PM. \n\nYou are Sarah Johnson, the Project Manager. The email should remind John to bring his quarterly reports and budget proposals. Keep it professional but friendly.`,
                response: `<tool_call>
<function=write_email</function>
<parameter=to>john@example.com</parameter>
<parameter=subject>Reminder: Q4 Planning Meeting Tomorrow at 2 PM</parameter>
<parameter=body>Hi John,

I hope you're doing well! This is a quick reminder about our Q4 planning meeting scheduled for tomorrow at 2 PM in Conference Room B.

Please remember to bring:
- Your quarterly reports for Q3
- Budget proposals for Q4
- Any additional materials you'd like to discuss

Looking forward to hearing your insights and discussing our strategy for the upcoming quarter.

Best regards,
Sarah Johnson
Project Manager</parameter>
</tool_call>`,
                chunks: ["<tool_call>\n", "<function=", "write_email", "</function>\n", "<parameter=to>", "john@example.com", "</parameter>\n", "<parameter=", "subject>", "Reminder: Q4 Planning Meeting ", "Tomorrow at 2 PM", "</parameter>\n", "<parameter=", "body>", "Hi John,\n\n", "I hope you're doing well! ", "This is a quick reminder ", "about our Q4 planning meeting ", "scheduled for tomorrow at 2 PM ", "in Conference Room B.\n\n", "Please remember to bring:\n", "- Your quarterly reports for Q3\n", "- Budget proposals for Q4\n", "- Any additional materials ", "you'd like to discuss\n\n", "Looking forward to hearing ", "your insights and discussing ", "our strategy for the ", "upcoming quarter.\n\n", "Best regards,\n", "Sarah Johnson\n", "Project Manager", "</parameter>\n", "</tool_call>"]
            },
            
            search: {
                prompt: "Search the production database for all users created after January 1, 2024. Limit results to 100.",
                response: `<tool_call>
<function=search_database</function>
<parameter=query>SELECT * FROM users WHERE created_at > '2024-01-01'</parameter>
<parameter=database>production</parameter>
<parameter=limit>100</parameter>
</tool_call>`,
                chunks: ["<tool_call>\n", "<function=", "search_database", "</function>\n", "<parameter=", "query>", "SELECT * FROM users ", "WHERE created_at > ", "'2024-01-01'", "</parameter>\n", "<parameter=", "database>", "production", "</parameter>\n", "<parameter=", "limit>", "100", "</parameter>\n", "</tool_call>"]
            },
            
            weather: {
                prompt: "Get the current weather for San Francisco in celsius.",
                response: `<tool_call>
<function=get_weather</function>
<parameter=city>San Francisco</parameter>
<parameter=units>celsius</parameter>
</tool_call>`,
                chunks: ["<tool_call>\n", "<function=", "get_weather", "</function>\n", "<parameter=", "city>", "San Francisco", "</parameter>\n", "<parameter=", "units>", "celsius", "</parameter>\n", "</tool_call>"]
            }
        };
        
        // Error Recovery System
        class ToolCallErrorRecovery {
            constructor() {
                this.maxRetries = 2;
                this.errorPatterns = {
                    noXML: {
                        test: (response) => !response.includes('<') || !response.includes('>'),
                        message: "Response contains no XML. Model may have answered directly instead of using tools.",
                        recovery: "strict"
                    },
                    wrongFormat: {
                        test: (response) => response.includes('name="') || response.includes("name='"),
                        message: "Response uses attribute-style XML instead of expected format.",
                        recovery: "format_reminder"
                    },
                    truncated: {
                        test: (response) => {
                            const trimmed = response.trim();
                            return trimmed.endsWith('<') || trimmed.endsWith('</') || 
                                   (trimmed.includes('<') && !trimmed.includes('</tool_call>'));
                        },
                        message: "Response appears truncated. Try with fewer max_tokens.",
                        recovery: "reduce_tokens"
                    },
                    directAnswer: {
                        test: (response) => {
                            // Check if it's a direct answer (like "5 + 3 = 8")
                            return /^\s*\d+\s*[+\-*/]\s*\d+\s*=\s*\d+\s*$/.test(response.trim());
                        },
                        message: "Model provided direct answer instead of using tools.",
                        recovery: "strict"
                    }
                };
            }

            diagnoseError(response, parseResult) {
                // Check each error pattern
                for (const [errorType, pattern] of Object.entries(this.errorPatterns)) {
                    if (pattern.test(response)) {
                        return {
                            type: errorType,
                            message: pattern.message,
                            recovery: pattern.recovery
                        };
                    }
                }
                
                // Generic error if no pattern matches
                if (!parseResult || parseResult.length === 0) {
                    return {
                        type: "parse_failed",
                        message: "Failed to parse tool calls from response.",
                        recovery: "retry"
                    };
                }
                
                return null;
            }

            createRecoveryPrompt(originalPrompt, errorDiagnosis, systemPrompt) {
                const recoveryStrategies = {
                    strict: {
                        system: `${systemPrompt}

CRITICAL ERROR: Your last response had NO XML tool calls!
You MUST respond with XML format like this:
<tool_call>
<function=tool_name</function>
<parameter=param>value</parameter>
</tool_call>

DO NOT explain or answer directly. USE TOOLS ONLY!

Refer to the tool schemas above and use the EXACT parameter names shown in the examples!`,
                        user: `${originalPrompt}

REMEMBER: Respond ONLY with XML tool calls!`,
                        temperature: 0.1,
                        max_tokens: 200
                    },
                    
                    format_reminder: {
                        system: `Your XML format was WRONG. 

WRONG (what you did): <function name="tool">
CORRECT (what you MUST do): <function=tool</function>

Use the CORRECT format with = signs!`,
                        user: originalPrompt,
                        temperature: 0.1,
                        max_tokens: 200
                    },
                    
                    reduce_tokens: {
                        system: systemPrompt,
                        user: `${originalPrompt}

Keep your response short and complete.`,
                        temperature: 0.2,
                        max_tokens: 150
                    },
                    
                    retry: {
                        system: systemPrompt,
                        user: originalPrompt,
                        temperature: 0.3,  // Slightly different temperature
                        max_tokens: 200
                    }
                };
                
                return recoveryStrategies[errorDiagnosis.recovery] || recoveryStrategies.retry;
            }
            
            // Extract intent as last resort fallback
            extractIntentFallback(prompt) {
                const promptLower = prompt.toLowerCase();
                
                // Calculator patterns
                const calcMatch = promptLower.match(/(\d+)\s*([+\-*/×÷])\s*(\d+)/);
                if (calcMatch) {
                    const operations = {'+': 'add', '-': 'subtract', '*': 'multiply', '×': 'multiply', '/': 'divide', '÷': 'divide'};
                    return [{
                        function: 'calculator',
                        parameters: {
                            operation: operations[calcMatch[2]] || 'add',
                            a: parseInt(calcMatch[1]),
                            b: parseInt(calcMatch[3])
                        },
                        fallback: true
                    }];
                }
                
                // Email pattern
                const emailMatch = prompt.match(/email\s+(?:to\s+)?([^\s]+@[^\s]+)/i);
                if (emailMatch || promptLower.includes('email')) {
                    return [{
                        function: 'write_email',
                        parameters: {
                            to: emailMatch ? emailMatch[1] : 'user@example.com',
                            subject: 'Email',
                            body: 'Email content'
                        },
                        fallback: true
                    }];
                }
                
                // Weather pattern
                const weatherMatch = prompt.match(/weather\s+(?:in|for)\s+([A-Za-z\s]+)/i);
                if (weatherMatch || promptLower.includes('weather')) {
                    return [{
                        function: 'get_weather',
                        parameters: {
                            city: weatherMatch ? weatherMatch[1].trim() : 'San Francisco',
                            units: 'celsius'
                        },
                        fallback: true
                    }];
                }
                
                return null;
            }
        }
        
        const errorRecovery = new ToolCallErrorRecovery();
        
        // Parse with automatic error recovery
        async function parseWithRecovery(response, originalPrompt, systemPrompt, streaming = false) {
            let attempts = 0;
            const maxAttempts = 3;
            
            // First attempt: standard parsing
            let parsed = parser.parse(response);
            if (parsed && parsed.length > 0) {
                return {
                    success: true,
                    toolCalls: parsed,
                    attempts: 1,
                    recoveryUsed: false
                };
            }
            
            // Don't do recovery for streaming mode - just return the parse result
            if (streaming) {
                return {
                    success: parsed && parsed.length > 0,
                    toolCalls: parsed || [],
                    attempts: 1,
                    recoveryUsed: false
                };
            }
            
            // Diagnose the error
            const diagnosis = errorRecovery.diagnoseError(response, parsed);
            if (!diagnosis) {
                return {
                    success: false,
                    toolCalls: [],
                    error: "Unknown error",
                    attempts: 1
                };
            }
            
            console.log(`Error detected: ${diagnosis.message}`);
            showStatus(`Error detected: ${diagnosis.message}. Attempting recovery...`, 'error');
            
            // Attempt recovery with retries
            while (attempts < maxAttempts) {
                attempts++;
                
                const recoveryPrompt = errorRecovery.createRecoveryPrompt(
                    originalPrompt, 
                    diagnosis, 
                    systemPrompt
                );
                
                try {
                    // Make recovery API call
                    const formattedPrompt = `<|im_start|>system
${recoveryPrompt.system}<|im_end|>
<|im_start|>user
${recoveryPrompt.user}<|im_end|>
<|im_start|>assistant
`;
                    
                    const payload = {
                        prompt: formattedPrompt,
                        max_tokens: recoveryPrompt.max_tokens,
                        temperature: recoveryPrompt.temperature,
                        top_p: 0.95,
                        top_k: 5,  // More restrictive for recovery
                        repetition_penalty: 1.0,
                        stream: false
                    };
                    
                    const response = await fetch(`${getBaseUrl()}/v1/completions`, {
                        method: 'POST',
                        headers: getApiHeaders(),
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const recoveredText = data.choices[0].text;
                        
                        // Update display with recovery attempt
                        document.getElementById('xmlInput').value = recoveredText;
                        document.getElementById('rawResponse').textContent = recoveredText;
                        
                        // Try parsing recovered response
                        parsed = parser.parse(recoveredText);
                        if (parsed && parsed.length > 0) {
                            return {
                                success: true,
                                toolCalls: parsed,
                                attempts: attempts + 1,
                                recoveryUsed: true,
                                recoveryMethod: 'reprompt',
                                diagnosis: diagnosis
                            };
                        }
                    }
                } catch (error) {
                    console.error('Recovery attempt failed:', error);
                }
            }
            
            // Last resort: try intent extraction
            const extracted = errorRecovery.extractIntentFallback(originalPrompt);
            if (extracted) {
                // Show what we extracted
                document.getElementById('xmlInput').value = `<!-- Intent extracted from: "${originalPrompt}" -->\n<!-- Note: This is a fallback reconstruction -->`;
                
                return {
                    success: true,
                    toolCalls: extracted,
                    attempts: attempts + 1,
                    recoveryUsed: true,
                    recoveryMethod: 'intent_extraction',
                    warning: 'Used fallback intent extraction - results may not be accurate',
                    diagnosis: diagnosis
                };
            }
            
            // All recovery attempts failed
            return {
                success: false,
                toolCalls: [],
                error: diagnosis.message,
                attempts: attempts,
                diagnosis: diagnosis
            };
        }

        function parseToolCall() {
            const input = document.getElementById('xmlInput').value;
            const outputSection = document.getElementById('outputSection');
            const jsonView = document.getElementById('jsonView');
            const statusMessage = document.getElementById('statusMessage');
            
            if (!input.trim()) {
                showStatus('Please enter XML tool call content', 'error');
                return;
            }

            try {
                const toolCalls = parser.parse(input);
                
                if (toolCalls.length === 0) {
                    showStatus('No valid tool calls found', 'error');
                    outputSection.innerHTML = '<p style="color: #999; text-align: center;">No valid tool calls found in input</p>';
                    jsonView.innerHTML = '<pre>{}</pre>';
                    return;
                }

                // Display parsed tool calls
                outputSection.innerHTML = '';
                toolCalls.forEach((call, index) => {
                    outputSection.appendChild(createToolCallDisplay(call, index));
                });

                // Show JSON representation without raw field for cleaner display
                const cleanedCalls = toolCalls.map(call => ({
                    function: call.function,
                    parameters: call.parameters
                }));
                jsonView.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${JSON.stringify(cleanedCalls, null, 2)}</pre>`;
                
                showStatus(`Successfully parsed ${toolCalls.length} tool call(s)`, 'success');
                updateFailureCount();
            } catch (error) {
                showStatus(`Parse error: ${error.message}`, 'error');
                outputSection.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
            }
        }

        function createToolCallDisplay(toolCall, index) {
            const div = document.createElement('div');
            div.className = 'tool-call-display';
            
            let html = `
                <div class="tool-call-header">
                    <div class="tool-icon">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        </svg>
                    </div>
                    <div class="function-name">${toolCall.function}</div>
                    ${toolCall.fallback ? '<span class="recovery-indicator">Intent Extracted</span>' : ''}
                    ${toolCall.truncated ? '<span class="recovery-indicator">Truncated</span>' : ''}
                </div>
                <div class="parameters">
            `;
            
            for (const [key, value] of Object.entries(toolCall.parameters)) {
                html += `
                    <div class="parameter">
                        <span class="param-name">${key}:</span>
                        <span class="param-value">${typeof value === 'object' ? JSON.stringify(value) : value}</span>
                    </div>
                `;
            }
            
            html += `
                </div>
                <div class="raw-xml" style="display: none;" id="raw-${index}">${escapeHtml(toolCall.raw)}</div>
                <button onclick="toggleRaw(${index})" style="margin-top: 10px; padding: 5px 10px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 3px; cursor: pointer;">Toggle Raw XML</button>
            `;
            
            div.innerHTML = html;
            return div;
        }

        function toggleRaw(index) {
            const rawDiv = document.getElementById(`raw-${index}`);
            rawDiv.style.display = rawDiv.style.display === 'none' ? 'block' : 'none';
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        function clearInput() {
            document.getElementById('xmlInput').value = '';
            document.getElementById('outputSection').innerHTML = '<p style="color: #999; text-align: center;">Parsed tool calls will appear here...</p>';
            document.getElementById('jsonView').innerHTML = '<pre>{}</pre>';
            document.getElementById('statusMessage').style.display = 'none';
            document.getElementById('tokenStream').style.display = 'none';
        }

        function showStatus(message, type) {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`;
            statusMessage.style.display = 'block';
            
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 3000);
        }


        function simulateStreaming() {
            // Check if we're using a quick prompt
            const promptInput = document.getElementById('promptInput').value.trim();
            let simulatedData = null;
            let useSimulated = false;
            
            // Try to match with our simulated responses
            for (const [key, data] of Object.entries(simulatedResponses)) {
                if (promptInput === data.prompt) {
                    simulatedData = data;
                    useSimulated = true;
                    break;
                }
            }
            
            const input = useSimulated ? simulatedData.response : document.getElementById('xmlInput').value;
            if (!input.trim()) {
                showStatus('Please enter XML content or select a quick prompt to simulate streaming', 'error');
                return;
            }
            
            // Update UI elements
            const xmlInputEl = document.getElementById('xmlInput');
            const tokenStream = document.getElementById('tokenStream');
            const streamContent = document.getElementById('streamContent');
            const outputSection = document.getElementById('outputSection');
            const jsonView = document.getElementById('jsonView');
            const rawResponse = document.getElementById('rawResponse');
            const rawJsonResponse = document.getElementById('rawJsonResponse');
            
            // Clear previous content
            xmlInputEl.value = '';
            outputSection.innerHTML = '<p style="color: #999; text-align: center;">Streaming response...</p>';
            jsonView.innerHTML = '<pre>Streaming...</pre>';
            rawResponse.innerHTML = '<span style="color: #999;">Streaming...</span>';
            tokenStream.style.display = 'block';
            streamContent.textContent = '';
            
            let index = 0;
            const chunks = useSimulated ? simulatedData.chunks : input.match(/.{1,5}|./g) || [];
            let accumulated = '';
            
            // Faster streaming speed - 20ms instead of 50ms
            const interval = setInterval(() => {
                if (index >= chunks.length) {
                    clearInterval(interval);
                    
                    // Final update
                    xmlInputEl.value = accumulated;
                    rawResponse.textContent = accumulated;
                    
                    // Parse and display
                    parseToolCall();
                    
                    // Show simulated JSON response
                    if (useSimulated) {
                        const simulatedJson = {
                            id: "cmpl-" + Math.random().toString(36).substr(2, 9),
                            object: "text_completion",
                            created: Date.now(),
                            model: "stelterlab/Qwen3-Coder-30B-A3B-Instruct-AWQ",
                            choices: [{
                                index: 0,
                                text: accumulated,
                                logprobs: null,
                                finish_reason: "stop",
                                stop_reason: null
                            }],
                            usage: {
                                prompt_tokens: promptInput.split(' ').length * 2,
                                completion_tokens: accumulated.split(' ').length,
                                total_tokens: (promptInput.split(' ').length * 2) + accumulated.split(' ').length
                            }
                        };
                        rawJsonResponse.innerHTML = `<pre style="margin: 0; color: #d4d4d4;">${JSON.stringify(simulatedJson, null, 2)}</pre>`;
                    }
                    
                    setTimeout(() => {
                        tokenStream.style.display = 'none';
                        showStatus('Simulated streaming completed', 'success');
                    }, 1000);
                    return;
                }
                
                // Add next chunk
                accumulated += chunks[index];
                streamContent.textContent = accumulated;
                xmlInputEl.value = accumulated;
                rawResponse.textContent = accumulated;
                
                // Try to parse partial content
                if (accumulated.includes('<tool_call>') || accumulated.includes('<function=')) {
                    const partialCalls = parser.parse(accumulated);
                    if (partialCalls.length > 0) {
                        outputSection.innerHTML = '';
                        partialCalls.forEach((call, i) => {
                            outputSection.appendChild(createToolCallDisplay(call, i));
                        });
                        
                        // Update JSON view with partial parse
                        const cleanedCalls = partialCalls.map(call => ({
                            function: call.function,
                            parameters: call.parameters
                        }));
                        jsonView.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${JSON.stringify(cleanedCalls, null, 2)}</pre>`;
                    }
                }
                
                index++;
            }, 20); // Faster: 20ms per chunk instead of 50ms
        }

        // VLLM API Configuration and Settings Management
        const DEFAULT_SETTINGS = {
            serverUrl: 'http://localhost',
            serverPort: 8000,
            temperature: 0.3,
            topP: 0.95,
            minP: 0.05,
            apiKey: ''
        };
        
        let currentSettings = { ...DEFAULT_SETTINGS };
        let currentStreamController = null;
        
        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('vllmSettings');
            if (saved) {
                try {
                    currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
                } catch (e) {
                    console.error('Failed to load settings:', e);
                    currentSettings = { ...DEFAULT_SETTINGS };
                }
            }
            return currentSettings;
        }
        
        // Get computed base URL
        function getBaseUrl() {
            return `${currentSettings.serverUrl}:${currentSettings.serverPort}`;
        }
        
        // Get API headers with optional API key
        function getApiHeaders() {
            const headers = {
                'Content-Type': 'application/json'
            };
            
            if (currentSettings.apiKey) {
                headers['Authorization'] = `Bearer ${currentSettings.apiKey}`;
            }
            
            return headers;
        }
        
        // Settings modal functions
        function openSettings() {
            const modal = document.getElementById('settingsModal');
            const settings = loadSettings();
            
            // Populate form with current settings
            document.getElementById('serverUrl').value = settings.serverUrl;
            document.getElementById('serverPort').value = settings.serverPort;
            document.getElementById('temperature').value = settings.temperature;
            document.getElementById('topP').value = settings.topP;
            document.getElementById('minP').value = settings.minP || 0.05;
            document.getElementById('apiKey').value = settings.apiKey || '';
            
            modal.style.display = 'block';
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }
        
        function saveSettings() {
            const newSettings = {
                serverUrl: document.getElementById('serverUrl').value || DEFAULT_SETTINGS.serverUrl,
                serverPort: parseInt(document.getElementById('serverPort').value) || DEFAULT_SETTINGS.serverPort,
                temperature: parseFloat(document.getElementById('temperature').value) || DEFAULT_SETTINGS.temperature,
                topP: parseFloat(document.getElementById('topP').value) || DEFAULT_SETTINGS.topP,
                minP: parseFloat(document.getElementById('minP').value) || DEFAULT_SETTINGS.minP,
                apiKey: document.getElementById('apiKey').value || DEFAULT_SETTINGS.apiKey
            };
            
            // Validate settings
            if (newSettings.serverPort < 1 || newSettings.serverPort > 65535) {
                showStatus('Port must be between 1 and 65535', 'error');
                return;
            }
            
            if (newSettings.temperature < 0 || newSettings.temperature > 2) {
                showStatus('Temperature must be between 0 and 2', 'error');
                return;
            }
            
            if (newSettings.topP < 0 || newSettings.topP > 1) {
                showStatus('Top P must be between 0 and 1', 'error');
                return;
            }
            
            if (newSettings.minP < 0 || newSettings.minP > 1) {
                showStatus('Min P must be between 0 and 1', 'error');
                return;
            }
            
            // Save to localStorage
            localStorage.setItem('vllmSettings', JSON.stringify(newSettings));
            currentSettings = newSettings;
            
            showStatus('Settings saved successfully', 'success');
            closeSettings();
        }
        
        function resetSettings() {
            if (confirm('Reset all settings to defaults?')) {
                localStorage.removeItem('vllmSettings');
                currentSettings = { ...DEFAULT_SETTINGS };
                
                // Update form
                document.getElementById('serverUrl').value = DEFAULT_SETTINGS.serverUrl;
                document.getElementById('serverPort').value = DEFAULT_SETTINGS.serverPort;
                document.getElementById('temperature').value = DEFAULT_SETTINGS.temperature;
                document.getElementById('topP').value = DEFAULT_SETTINGS.topP;
                document.getElementById('minP').value = DEFAULT_SETTINGS.minP;
                document.getElementById('apiKey').value = DEFAULT_SETTINGS.apiKey;
                
                showStatus('Settings reset to defaults', 'success');
            }
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target === modal) {
                closeSettings();
            }
        };

        // Function to generate system prompt with all tools
        function generateSystemPrompt() {
            let toolsSchema = '';
            let toolIndex = 1;
            
            // Add default tools
            toolsSchema += `1. calculator - Perform mathematical operations
   Parameters:
   - operation: (required) The operation to perform. Must be one of: "add", "subtract", "multiply", "divide"
   - a: (required) First number (integer or float)
   - b: (required) Second number (integer or float)
   
   Example:
   <tool_call>
   <function=calculator</function>
   <parameter=operation>multiply</parameter>
   <parameter=a>15</parameter>
   <parameter=b>23</parameter>
   </tool_call>\n\n`;
   
            toolsSchema += `2. write_email - Compose and send emails
   Parameters:
   - to: (required) Recipient email address
   - subject: (required) Email subject line
   - body: (required) Email body content
   - cc: (optional) CC recipients
   - priority: (optional) Email priority level
   
   Example:
   <tool_call>
   <function=write_email</function>
   <parameter=to>john@example.com</parameter>
   <parameter=subject>Meeting Reminder</parameter>
   <parameter=body>Hi John, just a reminder about our meeting tomorrow at 2 PM.</parameter>
   </tool_call>\n\n`;
   
            toolsSchema += `3. search_database - Query databases for information
   Parameters:
   - query: (required) SQL query or search string
   - database: (required) Database name to search
   - limit: (optional) Maximum number of results (default: 100)
   - include_metadata: (optional) Include metadata in results (true/false)
   
   Example:
   <tool_call>
   <function=search_database</function>
   <parameter=query>SELECT * FROM users WHERE created_at > '2024-01-01'</parameter>
   <parameter=database>production</parameter>
   <parameter=limit>50</parameter>
   </tool_call>\n\n`;
   
            toolsSchema += `4. get_weather - Get weather information for a location
   Parameters:
   - city: (required) City name
   - units: (optional) Temperature units - "celsius" or "fahrenheit" (default: "celsius")
   
   Example:
   <tool_call>
   <function=get_weather</function>
   <parameter=city>San Francisco</parameter>
   <parameter=units>celsius</parameter>
   </tool_call>\n\n`;
   
            toolsSchema += `5. edit_paragraph - Edit or improve text paragraphs
   Parameters:
   - paragraph_id: (required) ID of the paragraph to edit
   - reason: (required) Reason for editing
   - new_content: (required) The improved paragraph content
   
   Example:
   <tool_call>
   <function=edit_paragraph</function>
   <parameter=paragraph_id>1</parameter>
   <parameter=reason>Grammar and clarity improvements</parameter>
   <parameter=new_content>The revised paragraph with better grammar and flow.</parameter>
   </tool_call>\n\n`;
   
            toolIndex = 6;
            
            // Add custom tools
            console.log('Adding custom tools to system prompt:', customTools);
            Object.entries(customTools).forEach(([key, tool]) => {
                console.log(`Processing custom tool ${key}:`, tool);
                if (tool.definition) {
                    toolsSchema += `${toolIndex}. ${tool.definition.name} - ${tool.definition.description}\n`;
                    
                    if (tool.definition.parameters) {
                        toolsSchema += `   Parameters:\n`;
                        Object.entries(tool.definition.parameters).forEach(([paramName, param]) => {
                            toolsSchema += `   - ${paramName}: (${param.required ? 'required' : 'optional'}) ${param.description}\n`;
                        });
                    }
                    
                    if (tool.definition.example_xml) {
                        toolsSchema += `   \n   Example:\n   ${tool.definition.example_xml}\n\n`;
                    }
                    
                    toolIndex++;
                }
            });
            
            return `You are an AI assistant that MUST use tools for any task requested.

CRITICAL INSTRUCTIONS:
- You MUST ALWAYS respond with XML tool calls
- You MUST NEVER respond with plain text explanations
- You MUST use the exact XML format shown below
- Even if you think you can answer without tools, you MUST use a tool

Tool call format:
<tool_call>
<function=tool_name</function>
<parameter=param_name>param_value</parameter>
</tool_call>

IMPORTANT: Parameter values go INSIDE the tags like this:
CORRECT: <parameter=operation>multiply</parameter>
WRONG: <parameter=operation></parameter>multiply

AVAILABLE TOOLS WITH SCHEMAS:

${toolsSchema}REMEMBER: Always respond ONLY with tool calls in XML format!`;
        }

        async function callVLLM(streaming = false) {
            const userPrompt = document.getElementById('promptInput').value;
            if (!userPrompt.trim()) {
                showStatus('Please enter a prompt for VLLM', 'error');
                return;
            }

            const xmlInput = document.getElementById('xmlInput');
            const outputSection = document.getElementById('outputSection');
            const jsonView = document.getElementById('jsonView');
            const tokenStream = document.getElementById('tokenStream');
            const streamContent = document.getElementById('streamContent');
            const stopBtn = document.getElementById('stopStreamBtn');
            const rawResponse = document.getElementById('rawResponse');
            const rawJsonResponse = document.getElementById('rawJsonResponse');

            // Clear previous output
            xmlInput.value = '';
            outputSection.innerHTML = '<p style="color: #999; text-align: center;">Waiting for VLLM response...</p>';
            jsonView.innerHTML = '<pre>Generating...</pre>';
            rawResponse.innerHTML = '<span style="color: #999;">Waiting for response...</span>';
            rawJsonResponse.innerHTML = '<pre style="margin: 0; color: #d4d4d4;">Waiting for JSON response...</pre>';
            
            // Build the proper chat template format
            // Generate system prompt with all tools
            const systemPrompt = generateSystemPrompt();
            
            // Format as chat template (Qwen3 uses specific template)
            const formattedPrompt = `<|im_start|>system
${systemPrompt}<|im_end|>
<|im_start|>user
${userPrompt}<|im_end|>
<|im_start|>assistant
`;

            // Load current settings
            const settings = loadSettings();
            
            const payload = {
                prompt: formattedPrompt,
                max_tokens: 500,      // Reduced to avoid rambling
                temperature: settings.temperature,
                top_p: settings.topP,
                min_p: settings.minP,
                top_k: 10,           // Lower to restrict choices
                repetition_penalty: 1.0,  // No penalty for tool calls
                stream: streaming
            };

            try {
                if (streaming) {
                    // Show stop button and token stream
                    stopBtn.style.display = 'inline-block';
                    tokenStream.style.display = 'block';
                    streamContent.textContent = '';
                    
                    // Create abort controller for streaming
                    currentStreamController = new AbortController();
                    
                    const response = await fetch(`${getBaseUrl()}/v1/completions`, {
                        method: 'POST',
                        headers: getApiHeaders(),
                        body: JSON.stringify(payload),
                        signal: currentStreamController.signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let accumulated = '';
                    let streamEvents = [];

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') {
                                    break;
                                }
                                try {
                                    const parsed = JSON.parse(data);
                                    streamEvents.push(parsed);
                                    
                                    if (parsed.choices && parsed.choices[0].text) {
                                        const text = parsed.choices[0].text;
                                        accumulated += text;
                                        streamContent.textContent = accumulated;
                                        
                                        // Update raw response display
                                        rawResponse.textContent = accumulated;
                                        
                                        // Update XML input
                                        xmlInput.value = accumulated;
                                        
                                        // Try to parse if we have tool calls (check for function tag too)
                                        if (accumulated.includes('<function=') || accumulated.includes('<tool_call>')) {
                                            const streamResult = await parseWithRecovery(accumulated, userPrompt, systemPrompt, true);
                                            if (streamResult.success && streamResult.toolCalls.length > 0) {
                                                outputSection.innerHTML = '';
                                                streamResult.toolCalls.forEach((call, index) => {
                                                    outputSection.appendChild(createToolCallDisplay(call, index));
                                                });
                                                const cleanedCalls = streamResult.toolCalls.map(call => ({
                                                    function: call.function,
                                                    parameters: call.parameters
                                                }));
                                                jsonView.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${JSON.stringify(cleanedCalls, null, 2)}</pre>`;
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.error('Parse error:', e);
                                }
                            }
                        }
                    }
                    
                    // Display accumulated stream events in JSON response area
                    if (streamEvents.length > 0) {
                        const summary = {
                            stream: true,
                            events: streamEvents.length,
                            first_event: streamEvents[0],
                            last_event: streamEvents[streamEvents.length - 1],
                            complete_text: accumulated
                        };
                        rawJsonResponse.innerHTML = `<pre style="margin: 0; color: #d4d4d4;">${JSON.stringify(summary, null, 2)}</pre>`;
                    }

                    // Hide stop button
                    stopBtn.style.display = 'none';
                    
                    // Final parse with recovery
                    if (accumulated) {
                        xmlInput.value = accumulated;
                        
                        const finalResult = await parseWithRecovery(accumulated, userPrompt, systemPrompt, false);
                        
                        if (finalResult.success) {
                            // Display parsed tool calls
                            outputSection.innerHTML = '';
                            finalResult.toolCalls.forEach((call, index) => {
                                outputSection.appendChild(createToolCallDisplay(call, index));
                            });
                            
                            // Show JSON representation
                            const cleanedCalls = finalResult.toolCalls.map(call => ({
                                function: call.function,
                                parameters: call.parameters
                            }));
                            jsonView.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${JSON.stringify(cleanedCalls, null, 2)}</pre>`;
                            
                            if (finalResult.recoveryUsed) {
                                showStatus(`Streaming completed with recovery (${finalResult.recoveryMethod})`, 'success');
                            } else {
                                showStatus('Streaming completed successfully', 'success');
                            }
                        } else {
                            // Show parse error
                            outputSection.innerHTML = `<div style="color: #f87171; padding: 20px; background: #3a1a1e; border-radius: 5px; border: 1px solid #5a2a2e;">
                                <h3 style="color: #f87171;">Parse Error</h3>
                                <p>${finalResult.error}</p>
                                <p>The model's response could not be parsed as a valid tool call.</p>
                            </div>`;
                            jsonView.innerHTML = '<pre>{}</pre>';
                            showStatus(`Streaming completed but parsing failed: ${finalResult.error}`, 'error');
                        }
                        
                        // Keep the raw response visible
                        rawResponse.textContent = accumulated;
                    }
                    
                    // Hide token stream after delay
                    setTimeout(() => {
                        tokenStream.style.display = 'none';
                    }, 2000);

                } else {
                    // Non-streaming request
                    const response = await fetch(`${getBaseUrl()}/v1/completions`, {
                        method: 'POST',
                        headers: getApiHeaders(),
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const text = data.choices[0].text;
                    
                    // Display raw JSON response
                    rawJsonResponse.innerHTML = `<pre style="margin: 0; color: #d4d4d4;">${JSON.stringify(data, null, 2)}</pre>`;
                    
                    // Display raw text response
                    rawResponse.textContent = text;
                    
                    // Parse with error recovery
                    const result = await parseWithRecovery(text, userPrompt, systemPrompt, false);
                    
                    if (result.success) {
                        // Update XML input with response
                        xmlInput.value = text;
                        
                        // Display parsed tool calls
                        outputSection.innerHTML = '';
                        result.toolCalls.forEach((call, index) => {
                            outputSection.appendChild(createToolCallDisplay(call, index));
                        });
                        
                        // Show JSON representation
                        const cleanedCalls = result.toolCalls.map(call => ({
                            function: call.function,
                            parameters: call.parameters
                        }));
                        jsonView.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${JSON.stringify(cleanedCalls, null, 2)}</pre>`;
                        
                        // Show recovery info if used
                        if (result.recoveryUsed) {
                            let statusMsg = `Recovered using ${result.recoveryMethod} (${result.attempts} attempts)`;
                            if (result.warning) {
                                statusMsg += ` - ${result.warning}`;
                            }
                            showStatus(statusMsg, 'success');
                        } else if (data.usage) {
                            showStatus(`Response received (${data.usage.total_tokens} tokens)`, 'success');
                        } else {
                            showStatus('Response received successfully', 'success');
                        }
                    } else {
                        // Parse failed even after recovery
                        xmlInput.value = text;
                        outputSection.innerHTML = `<div style="color: #f87171; padding: 20px; background: #3a1a1e; border-radius: 5px; border: 1px solid #5a2a2e;">
                            <h3 style="color: #f87171;">Parse Error</h3>
                            <p>${result.error}</p>
                            <p>Attempts made: ${result.attempts}</p>
                            <h4 style="color: #e0e0e0;">Suggestions:</h4>
                            <ul style="color: #b0b0b0;">
                                <li>Try rephrasing your request more specifically</li>
                                <li>Start with an action verb like 'Calculate', 'Send', 'Get'</li>
                                <li>Use simpler, clearer language</li>
                            </ul>
                        </div>`;
                        jsonView.innerHTML = '<pre>{}</pre>';
                        showStatus(`Parse failed after ${result.attempts} attempts: ${result.error}`, 'error');
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showStatus('Streaming stopped by user', 'error');
                } else {
                    showStatus(`Error calling VLLM: ${error.message}`, 'error');
                    console.error('VLLM Error:', error);
                }
                outputSection.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
                jsonView.innerHTML = '<pre>Error occurred</pre>';
                stopBtn.style.display = 'none';
                tokenStream.style.display = 'none';
            }
        }

        function stopStreaming() {
            if (currentStreamController) {
                currentStreamController.abort();
                currentStreamController = null;
            }
            document.getElementById('stopStreamBtn').style.display = 'none';
        }

        // Add some example prompts
        function loadPromptExample(type) {
            const promptInput = document.getElementById('promptInput');
            const examples = {
                calculator: `Use the calculator tool to multiply 15 by 23.`,
                
                edit: `Use the edit_paragraph tool to improve this paragraph:

"The conference room was busy. People were talking and working on their laptops. The meeting would start soon. Everyone seemed prepared for the presentation."

This paragraph (ID: 1) needs to be more engaging and descriptive. Use the edit_paragraph tool to enhance it with better flow, sensory details, and more vivid language.`,
                
                email: `Write an email to john@example.com about tomorrow's Q4 planning meeting at 2 PM. 

You are Sarah Johnson, the Project Manager. The email should remind John to bring his quarterly reports and budget proposals. Keep it professional but friendly.`,
                
                search: `Search the production database for all users created after January 1, 2024. Limit results to 100.`,
                
                weather: `Get the current weather for San Francisco in celsius.`
            };
            
            promptInput.value = examples[type] || '';
            updateRequestPreview();
        }

        // Custom Tools Management
        const DEFAULT_TOOLS = {
            calculator: { 
                label: 'Calculator',
                prompt: 'Use the calculator tool to multiply 15 by 23.',
                removable: false
            },
            edit: { 
                label: 'Edit Text',
                prompt: `Use the edit_paragraph tool to improve this paragraph:\n\n"The conference room was busy. People were talking and working on their laptops. The meeting would start soon. Everyone seemed prepared for the presentation."\n\nThis paragraph (ID: 1) needs to be more engaging and descriptive. Use the edit_paragraph tool to enhance it with better flow, sensory details, and more vivid language.`,
                removable: false
            },
            email: { 
                label: 'Write Email',
                prompt: `Write an email to john@example.com about tomorrow's Q4 planning meeting at 2 PM. \n\nYou are Sarah Johnson, the Project Manager. The email should remind John to bring his quarterly reports and budget proposals. Keep it professional but friendly.`,
                removable: false
            },
            search: { 
                label: 'Search',
                prompt: 'Search the production database for all users created after January 1, 2024. Limit results to 100.',
                removable: false
            },
            weather: { 
                label: 'Weather',
                prompt: 'Get the current weather for San Francisco in celsius.',
                removable: false
            }
        };
        
        let customTools = {};
        let currentToolDefinition = null;
        
        function loadCustomTools() {
            const saved = localStorage.getItem('customTools');
            if (saved) {
                try {
                    customTools = JSON.parse(saved);
                    console.log('Loaded custom tools:', customTools);
                } catch (e) {
                    console.error('Failed to load custom tools:', e);
                    customTools = {};
                }
            }
            renderQuickPrompts();
        }
        
        function saveCustomTools() {
            localStorage.setItem('customTools', JSON.stringify(customTools));
            renderQuickPrompts();
        }
        
        function renderQuickPrompts() {
            const container = document.getElementById('quickPromptsList');
            container.innerHTML = '';
            
            // Render default tools
            Object.entries(DEFAULT_TOOLS).forEach(([key, tool]) => {
                const item = document.createElement('div');
                item.className = 'quick-prompt-item';
                item.innerHTML = `
                    <button onclick="loadPromptExample('${key}')" style="background: transparent; border: none; color: #e0e0e0; cursor: pointer;">
                        ${tool.label}
                    </button>
                `;
                container.appendChild(item);
            });
            
            // Render custom tools
            Object.entries(customTools).forEach(([key, tool]) => {
                const item = document.createElement('div');
                item.className = 'quick-prompt-item';
                item.innerHTML = `
                    <button onclick="loadPromptExample('${key}')" style="background: transparent; border: none; color: #e0e0e0; cursor: pointer;">
                        ${tool.label}
                    </button>
                    <button class="remove-prompt-btn" onclick="removeCustomTool('${key}')" title="Remove">×</button>
                `;
                container.appendChild(item);
            });
        }
        
        function loadPromptExample(type) {
            const promptInput = document.getElementById('promptInput');
            const tool = DEFAULT_TOOLS[type] || customTools[type];
            
            if (tool) {
                promptInput.value = tool.prompt;
                updateRequestPreview();
            }
        }
        
        function removeCustomTool(key) {
            if (confirm(`Remove "${customTools[key].label}" from quick prompts?`)) {
                delete customTools[key];
                saveCustomTools();
                showStatus('Tool removed from quick prompts', 'success');
            }
        }
        
        // Tool Builder Functions
        function openToolBuilder() {
            document.getElementById('toolBuilderModal').style.display = 'block';
            resetToolBuilder();
        }
        
        function closeToolBuilder() {
            document.getElementById('toolBuilderModal').style.display = 'none';
        }
        
        function resetToolBuilder() {
            document.getElementById('toolDescription').value = '';
            document.getElementById('toolName').value = '';
            document.getElementById('testPrompt').value = '';
            document.getElementById('quickPromptLabel').value = '';
            
            // Reset steps
            document.querySelectorAll('.tool-step').forEach(step => {
                step.classList.remove('active', 'completed', 'error');
                step.style.display = 'none';
            });
            
            document.getElementById('step1').classList.add('active');
            document.getElementById('step1').style.display = 'block';
            
            currentToolDefinition = null;
        }
        
        async function generateToolDefinition() {
            const description = document.getElementById('toolDescription').value.trim();
            const toolName = document.getElementById('toolName').value.trim();
            
            if (!description || !toolName) {
                showToolBuilderStatus('Please provide both a description and a tool name', 'error');
                return;
            }
            
            showToolBuilderStatus('Generating tool definition with AI...', 'warning');
            
            const prompt = `You are a tool definition generator. Create a detailed tool definition based on this description:

Description: ${description}
Tool Name: ${toolName}

Generate a complete tool definition in this exact format:
{
  "name": "${toolName}",
  "description": "Brief description of what the tool does",
  "parameters": {
    "param1": {
      "type": "string|number|boolean",
      "required": true,
      "description": "What this parameter is for"
    }
  },
  "example_prompt": "An example prompt that would use this tool",
  "example_xml": "<tool_call>\\n<function=${toolName}</function>\\n<parameter=param1>value</parameter>\\n</tool_call>"
}

Make sure the tool definition is practical and the parameters make sense for the described functionality.`;
            
            try {
                const settings = loadSettings();
                const response = await fetch(`${getBaseUrl()}/v1/completions`, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    body: JSON.stringify({
                        prompt: prompt,
                        max_tokens: 500,
                        temperature: 0.3,
                        top_p: settings.topP,
                        min_p: settings.minP
                    })
                });
                
                if (!response.ok) throw new Error('Failed to generate tool definition');
                
                const data = await response.json();
                const generatedText = data.choices[0].text;
                
                // Try to extract JSON from the response
                const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    try {
                        currentToolDefinition = JSON.parse(jsonMatch[0]);
                        displayGeneratedDefinition();
                        moveToStep(2);
                        showToolBuilderStatus('Tool definition generated successfully!', 'success');
                    } catch (e) {
                        showToolBuilderStatus('Failed to parse generated definition. Please try again.', 'error');
                    }
                } else {
                    showToolBuilderStatus('No valid JSON found in response. Please try again.', 'error');
                }
            } catch (error) {
                showToolBuilderStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        function displayGeneratedDefinition() {
            const container = document.getElementById('generatedDefinition');
            if (!currentToolDefinition) return;
            
            let html = `
                <h5 style="color: #6a6aae; margin-bottom: 10px;">${currentToolDefinition.name}</h5>
                <p style="color: #e0e0e0; margin-bottom: 15px;">${currentToolDefinition.description}</p>
                
                <h6 style="color: #6a6aae; margin-bottom: 10px;">Parameters:</h6>
                <ul style="color: #b0b0b0; margin-left: 20px;">
            `;
            
            Object.entries(currentToolDefinition.parameters || {}).forEach(([param, info]) => {
                html += `<li><strong>${param}</strong> (${info.type}, ${info.required ? 'required' : 'optional'}): ${info.description}</li>`;
            });
            
            html += `
                </ul>
                
                <h6 style="color: #6a6aae; margin-top: 15px; margin-bottom: 10px;">Example:</h6>
                <pre style="background: #0a0a1e; border: 1px solid #2a2a3e; padding: 10px; border-radius: 5px; color: #e0e0e0; white-space: pre-wrap;">${currentToolDefinition.example_xml}</pre>
            `;
            
            container.innerHTML = html;
        }
        
        async function validateToolDefinition() {
            showToolBuilderStatus('Validating tool definition...', 'warning');
            
            // Here we could add more sophisticated validation
            // For now, just check that the definition has required fields
            if (currentToolDefinition && 
                currentToolDefinition.name && 
                currentToolDefinition.description && 
                currentToolDefinition.example_xml) {
                
                moveToStep(3);
                document.getElementById('testPrompt').value = currentToolDefinition.example_prompt || '';
                showToolBuilderStatus('Tool definition validated!', 'success');
            } else {
                showToolBuilderStatus('Tool definition is incomplete. Please regenerate.', 'error');
            }
        }
        
        async function regenerateToolDefinition() {
            await generateToolDefinition();
        }
        
        async function testNewTool() {
            const testPrompt = document.getElementById('testPrompt').value.trim();
            if (!testPrompt) {
                showToolBuilderStatus('Please enter a test prompt', 'error');
                return;
            }
            
            showToolBuilderStatus('Testing tool with VLLM...', 'warning');
            
            // Update system prompt to include new tool
            const systemPrompt = getSystemPromptWithNewTool(currentToolDefinition);
            const formattedPrompt = `<|im_start|>system
${systemPrompt}<|im_end|>
<|im_start|>user
${testPrompt}<|im_end|>
<|im_start|>assistant
`;
            
            try {
                const settings = loadSettings();
                const response = await fetch(`${getBaseUrl()}/v1/completions`, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    body: JSON.stringify({
                        prompt: formattedPrompt,
                        max_tokens: 300,
                        temperature: settings.temperature,
                        top_p: settings.topP,
                        min_p: settings.minP
                    })
                });
                
                if (!response.ok) throw new Error('Failed to test tool');
                
                const data = await response.json();
                const result = data.choices[0].text;
                
                // Display test results
                const resultsDiv = document.getElementById('testResults');
                resultsDiv.style.display = 'block';
                resultsDiv.innerHTML = `
                    <h5 style="color: #6a6aae; margin-bottom: 10px;">Test Results:</h5>
                    <pre style="background: #0a0a1e; border: 1px solid #2a2a3e; padding: 10px; border-radius: 5px; color: #4ade80; white-space: pre-wrap;">${result}</pre>
                `;
                
                // Check if the tool was used correctly
                if (result.includes(`<function=${currentToolDefinition.name}`)) {
                    moveToStep(4);
                    document.getElementById('quickPromptLabel').value = currentToolDefinition.name.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                    showToolBuilderStatus('Tool tested successfully!', 'success');
                } else {
                    showToolBuilderStatus('Tool was not used in the response. Try adjusting the test prompt.', 'warning');
                }
            } catch (error) {
                showToolBuilderStatus(`Test error: ${error.message}`, 'error');
            }
        }
        
        function getSystemPromptWithNewTool(toolDef) {
            return `You are an AI assistant that MUST use tools for any task requested.

CRITICAL INSTRUCTIONS:
- You MUST ALWAYS respond with XML tool calls
- You MUST NEVER respond with plain text explanations
- You MUST use the exact XML format shown below
- Even if you think you can answer without tools, you MUST use a tool

Tool call format:
<tool_call>
<function=tool_name</function>
<parameter=param_name>param_value</parameter>
</tool_call>

AVAILABLE TOOLS:

${toolDef.name} - ${toolDef.description}
Parameters:
${Object.entries(toolDef.parameters).map(([param, info]) => 
    `- ${param}: (${info.required ? 'required' : 'optional'}) ${info.description}`
).join('\n')}

Example:
${toolDef.example_xml}

[Include other standard tools here...]

REMEMBER: Always respond ONLY with tool calls in XML format!`;
        }
        
        function saveNewTool() {
            const label = document.getElementById('quickPromptLabel').value.trim();
            const testPrompt = document.getElementById('testPrompt').value.trim();
            
            if (!label) {
                showToolBuilderStatus('Please provide a label for the quick prompt', 'error');
                return;
            }
            
            // Generate a unique key
            const key = 'custom_' + Date.now();
            
            // Save the tool
            customTools[key] = {
                label: label,
                prompt: testPrompt || currentToolDefinition.example_prompt,
                definition: currentToolDefinition,
                removable: true
            };
            
            saveCustomTools();
            closeToolBuilder();
            showStatus(`Tool "${label}" added to quick prompts!`, 'success');
            
            // Also update the system prompt to include custom tools
            updateSystemPromptWithCustomTools();
        }
        
        function updateSystemPromptWithCustomTools() {
            // This would update the main system prompt to include all custom tools
            // For now, we'll handle this dynamically when making requests
        }
        
        function moveToStep(stepNumber) {
            document.querySelectorAll('.tool-step').forEach((step, index) => {
                step.classList.remove('active');
                if (index < stepNumber - 1) {
                    step.classList.add('completed');
                }
                step.style.display = index < stepNumber ? 'block' : 'none';
            });
            
            document.getElementById(`step${stepNumber}`).classList.add('active');
        }
        
        function showToolBuilderStatus(message, type) {
            const statusDiv = document.getElementById('toolBuilderStatus');
            statusDiv.textContent = message;
            statusDiv.className = `status-message status-${type}`;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }
        
        // Load default example on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadSettings(); // Initialize settings
            loadCustomTools(); // Load custom tools
            updateFailureCount();
            updateRequestPreview();
        });
        
        // Request preview functionality
        let currentPreviewMode = 'formatted';
        
        function updateRequestPreview() {
            const userPrompt = document.getElementById('promptInput').value;
            const previewDiv = document.getElementById('requestPreview');
            
            if (!userPrompt.trim()) {
                previewDiv.innerHTML = '<span style="color: #999;">Enter a prompt to see the request preview...</span>';
                return;
            }
            
            // Generate system prompt with all tools
            const systemPrompt = generateSystemPrompt();
            
            // Format as chat template
            const formattedPrompt = `<|im_start|>system
${systemPrompt}<|im_end|>
<|im_start|>user
${userPrompt}<|im_end|>
<|im_start|>assistant
`;
            
            // Load current settings
            const settings = loadSettings();
            
            // Create payload
            const payload = {
                prompt: formattedPrompt,
                max_tokens: 500,
                temperature: settings.temperature,
                top_p: settings.topP,
                min_p: settings.minP,
                top_k: 10,
                repetition_penalty: 1.0,
                stream: false // Will be set to true for streaming
            };
            
            if (currentPreviewMode === 'formatted') {
                // Show formatted chat template with syntax highlighting
                const highlighted = formattedPrompt
                    .replace(/<\|im_start\|>system/g, '<span style="color: #569cd6;">&lt;|im_start|&gt;</span><span style="color: #ce9178;">system</span>')
                    .replace(/<\|im_end\|>/g, '<span style="color: #569cd6;">&lt;|im_end|&gt;</span>')
                    .replace(/<\|im_start\|>user/g, '<span style="color: #569cd6;">&lt;|im_start|&gt;</span><span style="color: #4ec9b0;">user</span>')
                    .replace(/<\|im_start\|>assistant/g, '<span style="color: #569cd6;">&lt;|im_start|&gt;</span><span style="color: #dcdcaa;">assistant</span>')
                    .replace(/(&lt;tool_call&gt;|&lt;\/tool_call&gt;|&lt;function=|&lt;\/function&gt;|&lt;parameter=|&lt;\/parameter&gt;)/g, '<span style="color: #ce9178;">$1</span>');
                
                previewDiv.innerHTML = highlighted;
            } else {
                // Show JSON payload
                previewDiv.innerHTML = `<span style="color: #ce9178;">POST ${getBaseUrl()}/v1/completions</span>\n\n` + 
                    JSON.stringify(payload, null, 2)
                        .replace(/"([^"]+)":/g, '<span style="color: #9cdcfe;">"$1"</span>:')
                        .replace(/: "([^"]+)"/g, ': <span style="color: #ce9178;">"$1"</span>')
                        .replace(/: (\d+\.?\d*)/g, ': <span style="color: #b5cea8;">$1</span>')
                        .replace(/: (true|false)/g, ': <span style="color: #569cd6;">$1</span>');
            }
        }
        
        function togglePreviewMode(mode) {
            currentPreviewMode = mode;
            
            // Update button styles
            const formattedBtn = document.getElementById('previewFormatted');
            const jsonBtn = document.getElementById('previewJson');
            
            if (mode === 'formatted') {
                formattedBtn.style.background = '#3a3a5e';
                jsonBtn.style.background = '#2a2a3e';
            } else {
                formattedBtn.style.background = '#2a2a3e';
                jsonBtn.style.background = '#3a3a5e';
            }
            
            updateRequestPreview();
        }
        
        // Failure log UI functions
        function updateFailureCount() {
            const failures = failureLogger.getFailures();
            const countEl = document.getElementById('failureCount');
            countEl.textContent = `${failures.length} failure${failures.length !== 1 ? 's' : ''} logged`;
        }
        
        function viewFailures() {
            const failures = failureLogger.getFailures();
            const display = document.getElementById('failuresDisplay');
            
            if (failures.length === 0) {
                display.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No parsing failures logged yet.</p>';
            } else {
                let html = '<div style="padding: 10px;">';
                
                failures.forEach((failure, index) => {
                    const date = new Date(failure.timestamp);
                    const timeStr = date.toLocaleString();
                    
                    html += `
                        <div style="background: #1a1a2e; border: 1px solid #3a3a5e; border-radius: 5px; padding: 15px; margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <div>
                                    <strong style="color: #f87171;">${failure.reason.replace(/_/g, ' ').toUpperCase()}</strong>
                                    <span style="color: #808080; font-size: 13px; margin-left: 10px;">${timeStr}</span>
                                </div>
                                <button onclick="replayFailure('${failure.id}')" style="padding: 4px 10px; background: #2a4a6e; color: white; border: 1px solid #3a5a7e; border-radius: 3px; cursor: pointer; font-size: 12px;">
                                    Replay
                                </button>
                            </div>
                            
                            <div style="background: #0a0a1e; border: 1px solid #2a2a3e; border-radius: 3px; padding: 10px; margin-bottom: 10px;">
                                <strong style="color: #e0e0e0;">Input:</strong>
                                <pre style="margin: 5px 0 0 0; white-space: pre-wrap; word-wrap: break-word; font-size: 12px; color: #b0b0b0;">${escapeHtml(failure.input)}</pre>
                            </div>
                            
                            ${failure.context.issues ? `
                                <div style="background: #3a3a1e; border: 1px solid #5a5a2e; border-radius: 3px; padding: 10px; margin-bottom: 10px;">
                                    <strong style="color: #fbbf24;">Issues:</strong>
                                    <ul style="margin: 5px 0 0 20px; font-size: 13px; color: #e0e0e0;">
                                        <li>Issue: ${failure.context.issues.issue}</li>
                                        <li>Expected ${failure.context.issues.expectedCount} parameters, found ${failure.context.issues.actualCount}</li>
                                        ${failure.context.issues.parsedParams ? `<li>Parsed: ${failure.context.issues.parsedParams.join(', ')}</li>` : ''}
                                    </ul>
                                </div>
                            ` : ''}
                            
                            ${failure.context.parsed ? `
                                <div style="background: #1a3a2e; border: 1px solid #2a5a4e; border-radius: 3px; padding: 10px;">
                                    <strong style="color: #4ade80;">What was parsed:</strong>
                                    <pre style="margin: 5px 0 0 0; font-size: 12px; color: #e0e0e0;">${JSON.stringify(failure.context.parsed, null, 2)}</pre>
                                </div>
                            ` : ''}
                            
                            <details style="margin-top: 10px;">
                                <summary style="cursor: pointer; color: #808080; font-size: 13px;">Full Context</summary>
                                <pre style="margin-top: 5px; font-size: 11px; color: #808080;">${JSON.stringify(failure, null, 2)}</pre>
                            </details>
                        </div>
                    `;
                });
                
                html += '</div>';
                display.innerHTML = html;
            }
            
            display.style.display = display.style.display === 'none' ? 'block' : 'none';
        }
        
        function clearFailures() {
            if (confirm('Are you sure you want to clear all parsing failure logs?')) {
                failureLogger.clearFailures();
                updateFailureCount();
                const display = document.getElementById('failuresDisplay');
                display.style.display = 'none';
                showStatus('Parsing failure log cleared', 'success');
            }
        }
        
        function exportFailures() {
            failureLogger.exportFailures();
            showStatus('Failure log exported', 'success');
        }
        
        function replayFailure(failureId) {
            const failures = failureLogger.getFailures();
            const failure = failures.find(f => f.id === failureId);
            
            if (failure) {
                document.getElementById('xmlInput').value = failure.input;
                parseToolCall();
                document.getElementById('failuresDisplay').style.display = 'none';
                showStatus('Replaying failed parsing attempt', 'warning');
            }
        }
    </script>
</body>
</html>